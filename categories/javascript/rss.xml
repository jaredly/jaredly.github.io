<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Jared Forsyth]]></title>
    <link>https://jaredforsyth.com/</link>
    <atom:link href="categories/javascript/rss.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[A blog about web development, programming languages, react, etc.]]></description>
    <pubDate>2017-12-31T04:10:48.000Z</pubDate>
    <generator>http://zespia.tw/hexo/</generator>
    
    <item>
      <title><![CDATA[JavaScript Interop with Reason and BuckleScript]]></title>
      <link>https://jaredforsyth.com/2017/06/03/javascript-interop-with-reason-and-bucklescript/</link>
      <guid>https://jaredforsyth.com/2017/06/03/javascript-interop-with-reason-and-bucklescript/</guid>
      <pubDate>Sun, 04 Jun 2017 04:00:35 GMT</pubDate>
      <description>
      <![CDATA[How to communicate safely and unsafely with the host language.]]>
      
      </description>
      <content:encoded><![CDATA[<p>So you‚Äôre all ready to write some Reason but you need to call a JavaScript function? Or maybe you can‚Äôt figure out how to write something in OCaml-land and wish you could just bail for a minute &amp; write it in JavaScript? Fortunately, both of those are fairly easy to pull off.</p>
<a id="more"></a>
<p>If you don‚Äôt already have Reason + BuckleScript set up on your machine, head over to the <a href="http://jaredforsyth.com/2017/06/03/getting-started-with-reason-and-bucklescript/">‚ÄúGetting Started‚Äù blog post</a> or clone <a href="https://github.com/jaredly/reason-bucklescript-example" target="_blank" rel="external">this github repository</a> for a minimal boilerplate. If you want a primer on Reason syntax, the <a href="http://facebook.github.io/reason/" target="_blank" rel="external">Reason documentation</a> provides a nice comparison to JavaScript.</p>
<blockquote>
<p>I‚Äôll be using Reason syntax instead of standard OCaml syntax because I like it much better :) but all of the stuff here applies to vanilla OCaml + Bucklescript as well, and the syntax is quite similar. The latest version of Bucklescript as of this writing is 1.7.4, so if yours is later than that, some details might be different. In all of this, you can consult the excellent <a href="http://bucklescript.github.io/bucklescript/Manual.html" target="_blank" rel="external">Bucklescript documentation</a>.</p>
</blockquote>
<h2 id="Just_dumping_JavaScript_in_the_middle_of_your_Reason_code">Just dumping JavaScript in the middle of your Reason code</h2><p>If you‚Äôre just hacking things together, this can be very nice, but you also have all of the unsafety of JavaScript code üòÑ.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Js</span>.log <span class="string">"this is reason"</span>;</span><br><span class="line">[%%bs.raw &#123;|</span><br><span class="line">console.log(<span class="symbol">'here</span> is some javascript <span class="keyword">for</span> you');</span><br><span class="line">|&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>{|</code> and <code>|}</code> are the delimeters of a multi-line string in OCaml. You can also put a tag in there e.g. <code>{something|</code> and then it will look for a matching <code>|something}</code> to close.</p>
</blockquote>
<p>And here‚Äôs the resulting javascript:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span></span><br><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"this is reason"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'here is some javascript for you'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Dumping_in_some_JavaScript,_and_making_it_accessible_from_Reason">Dumping in some JavaScript, and making it accessible from Reason</h2><p>What if you want a value that can be used from your Reason code?</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Js</span>.log <span class="string">"this is reason"</span>;</span><br><span class="line"><span class="keyword">let</span> x = [%bs.raw &#123;| <span class="symbol">'here</span> is a <span class="built_in">string</span> from javascript' |&#125;];</span><br><span class="line"><span class="type">Js</span>.log (x ^ <span class="string">" back in reason land"</span>); /* ^ is the operator <span class="keyword">for</span> <span class="built_in">string</span> concat */</span><br></pre></td></tr></table></figure>
<p>Now you might be wondering ‚Äúwhat magic is this?? How did ocaml know that <code>x</code> was a string? <strong>It doesn‚Äôt</strong>. The type of <code>x</code> in this code is a magic type that will unify with anything! This is quite dangerous and can have cascading effects in OCaml‚Äôs type inference algorithm.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y = [%bs.raw &#123;| <span class="symbol">'something'</span> |&#125;];</span><br><span class="line"><span class="type">Js</span>.log (<span class="string">"a string"</span> ^ y, <span class="number">10</span> + y);</span><br><span class="line">/* danger!! ocaml won't stop you from using y <span class="keyword">as</span> <span class="number">2</span> totally different types */</span><br></pre></td></tr></table></figure>
<p>To fix this, you should <strong>always</strong> provide a concrete type for the result of <code>bs.raw</code>.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">string</span> = [%bs.raw &#123;| <span class="symbol">'well</span>-typed' |&#125;];</span><br><span class="line"><span class="type">Js</span>.log (x ^ <span class="string">" back in reason land"</span>);</span><br><span class="line">/* ocaml will error out <span class="keyword">if</span> you <span class="keyword">try</span> <span class="keyword">to</span> use x <span class="keyword">as</span> anything other than a <span class="built_in">string</span> */</span><br></pre></td></tr></table></figure>
<p>And here‚Äôs the output!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span></span><br><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"this is reason"</span>);</span><br><span class="line"><span class="keyword">var</span> x = ( <span class="string">'here is a string from javascript'</span> );</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">" back in reason land"</span>);</span><br><span class="line"><span class="keyword">var</span> y = ( <span class="string">'something'</span> );</span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* tuple */</span>[</span><br><span class="line">      <span class="string">"a string"</span> + y,</span><br><span class="line">      <span class="number">10</span> + y | <span class="number">0</span></span><br><span class="line">    ]);</span><br><span class="line"><span class="keyword">var</span> x$<span class="number">1</span> = ( <span class="string">'well-typed'</span> );</span><br><span class="line"><span class="built_in">console</span>.log(x$<span class="number">1</span> + <span class="string">" back in reason land"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The difference between the 2 <code>%%</code> from the previous section and the 1 <code>%</code> here is important! <code>[%%something ...]</code> is an OCaml ‚Äúextension point‚Äù that represents a <em>top-level</em> statement (it can‚Äôt show up inside a function or value, for example). <code>[%something ...]</code> is an extension point that stands in for an <em>expression</em>, and can be put just about anywhere ‚Äì but make sure that the JavaScript you put inside is actually an expression! E.g. don‚Äôt put a semicolon after it, or you‚Äôll get a syntax error when you try to run the resulting JavaScript.</p>
</blockquote>
<h2 id="Dumping_in_a_function_&amp;_passing_values">Dumping in a function &amp; passing values</h2><p>We‚Äôll need a little knowledge about Bucklescript‚Äôs runtime representation of various values for this to work.</p>
<ul>
<li><code>strings</code> are strings, <code>ints</code> and <code>floats</code> are just numbers</li>
<li>an <a href="http://facebook.github.io/reason/#built-in-data-types-array" target="_blank" rel="external">Array</a> is a mutable fixed-length list in OCaml, and is represented as a plain javascript array.</li>
<li>a <a href="http://facebook.github.io/reason/#built-in-data-types-linked-list" target="_blank" rel="external">List</a> is an immutable functional-style linked list, and is definitely the more idiomatic one to use in most cases. However, it‚Äôs representation is more complicated (try <code>Js.log [1,2,3,4]</code> to check it out). Because of this, I generally convert to &amp; from <code>Array</code>s when I‚Äôm talking to javascript, via <code>Array.of_list</code> and <code>Array.to_list</code>.</li>
<li>If you want to go deeper, there‚Äôs an exhaustive list <a href="https://github.com/bucklescript/bucklescript/wiki/Runtime-representation" target="_blank" rel="external">on the BuckleScript wiki</a></li>
</ul>
<p>Knowing that, we can write a function in JavaScript that just accepts an array and returns a number, without much trouble at all.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsCalculate: <span class="built_in">array</span> <span class="built_in">int</span> =&gt; <span class="built_in">int</span> =&gt; <span class="built_in">int</span> = [%bs.raw &#123;|</span><br><span class="line"> <span class="keyword">function</span> (numbers, scaleFactor) &#123;</span><br><span class="line">   var result = <span class="number">0</span>;</span><br><span class="line">   numbers.forEach(number =&gt; &#123;</span><br><span class="line">     result += number;</span><br><span class="line">   &#125;);</span><br><span class="line">   return result * scaleFactor;</span><br><span class="line"> &#125;</span><br><span class="line">|&#125;];</span><br><span class="line"><span class="keyword">let</span> calculate numbers scaleFactor =&gt;</span><br><span class="line">  jsCalculate (<span class="type">Array</span>.of_list numbers) scaleFactor;</span><br><span class="line"><span class="type">Js</span>.log (calculate [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">10</span>); /* -&gt; <span class="number">60</span> */</span><br></pre></td></tr></table></figure>
<p>Of course, this function that I wrote in JavaScript could be ported over to Reason without much hassle.</p>
<p><strong>Remember</strong> that this is an escape hatch that‚Äôs very useful for learning so you can jump in quickly and make something, but it‚Äôs a good exercise to go back through and convert things back into nice type safe reason code.</p>
<p>I‚Äôve run into more than a few bugs because of raw JavaScript that I added to save time üòÖ.</p>
<h2 id="Settling_down_and_getting_disciplined_about_things">Settling down and getting disciplined about things</h2><p>So far we‚Äôve been using <code>bs.raw</code>, which is a very fast n loose way to do it, and <strong>not</strong> suitable for production.</p>
<p>But what if we actually need to call a function that‚Äôs in JavaScript? It‚Äôs needed for interacting with the DOM, or using node modules. In BuckleScript, you use an <code>external</code> declaration (<a href="http://bucklescript.github.io/bucklescript/Manual.html#_binding_to_simple_js_functions_values" target="_blank" rel="external">docs</a>).</p>
<p>Getting a value and getting a function are both pretty easy:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">external</span> pi: <span class="built_in">float</span> = <span class="string">"Math.PI"</span> [@@bs.<span class="keyword">val</span>];</span><br><span class="line"><span class="keyword">let</span> tau = pi *. <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">external</span> alert: <span class="built_in">string</span> =&gt; void = <span class="string">"alert"</span> [@@bs.<span class="keyword">val</span>];</span><br><span class="line">alert <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>But what about when we want something more complicated? Here‚Äôs how we could call <code>getContext</code> on a Canvas DOM node:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canvas;</span><br><span class="line"><span class="keyword">type</span> context;</span><br><span class="line">/* we're leaving these types abstract, because we won't</span><br><span class="line"> * be using them directly anywhere */</span><br><span class="line"><span class="keyword">external</span> getContext: canvas =&gt; <span class="built_in">string</span> =&gt; context = <span class="string">""</span> [@@bs.send];</span><br><span class="line"><span class="keyword">let</span> myCanvas: canvas = [%bs.raw &#123;| document.getElementById(<span class="string">"mycanvas"</span>) |&#125;];</span><br><span class="line"><span class="keyword">let</span> ctx = getContext myCanvas <span class="string">"2d"</span>;</span><br></pre></td></tr></table></figure>
<p>So let‚Äôs unpack what‚Äôs going on. We created some abstract types for the Canvas DOM node and the associated RenderingContext object.</p>
<p>Then we made a <code>getContext</code> function, but instead of <code>@@bs.val</code> we used <code>@@bs.send</code>, and we used an empty string for the text of the external. <code>@@bs.send</code> means ‚Äúwe‚Äôre calling a method on the first argument‚Äù, which in this case is the canvas. BuckleScript will translate this into <code>theFirstArgument.getContext(theSecondArgument, ...)</code>.</p>
<p>And the empty string means ‚Äúthe js-name is the same as the name we‚Äôre giving the external here in BuckleScript-land‚Äù, in this case <code>getContext</code>. If we wanted to name it something else (like <code>getRenderingContext</code>), when we‚Äôd have to supply the string <code>&quot;getContext&quot;</code> so that BuckleScript calls the right function.</p>
<p>Let‚Äôs add one more function just so it‚Äôs interesting.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">external</span> fillRect: context =&gt; <span class="built_in">float</span> =&gt; <span class="built_in">float</span> =&gt; <span class="built_in">float</span> =&gt; <span class="built_in">float</span> =&gt; <span class="built_in">unit</span> = <span class="string">""</span> [@@bs.send];</span><br></pre></td></tr></table></figure>
<p>And now we can draw something!</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fillRect ctx <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">100.0</span> <span class="number">100.0</span>;</span><br></pre></td></tr></table></figure>
<p>It‚Äôs not much, but adding other canvas methods is similar, and then you can start doing some <a href="https://twitter.com/jaredforsyth/status/871062358076030976" target="_blank" rel="external">really fun things</a>.</p>
<p>So what does the compiled JavaScript look like?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> tau = <span class="built_in">Math</span>.PI * <span class="number">2.0</span>;</span><br><span class="line">alert(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> myCanvas = ( <span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>) );</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">100.0</span>);</span><br></pre></td></tr></table></figure>
<p>Wow! Notice how BuckleScript just inlined our <code>pi</code> variable for us? And the output looks almost exactly like it was written by hand.</p>
<h2 id="What‚Äôs_next?">What‚Äôs next?</h2><p>Join us in our <a href="https://discord.gg/reasonml" target="_blank" rel="external">Discord channel!</a></p>
<p>Check out the <a href="https://github.com/chenglou/reason-react-example" target="_blank" rel="external">reason-react-example</a> repository if you want to make some UIs.</p>
<p>Here are some repositories that make use of externals:</p>
<ul>
<li><a href="https://github.com/jaredly/reason-maze" target="_blank" rel="external">https://github.com/jaredly/reason-maze</a></li>
<li><a href="https://github.com/jaredly/rsnpaint" target="_blank" rel="external">https://github.com/jaredly/rsnpaint</a></li>
<li><a href="https://github.com/chenglou/MariOCaml" target="_blank" rel="external">https://github.com/chenglou/MariOCaml</a> (OCaml, not Reason syntax)</li>
</ul>
<p>If you‚Äôre starting into Reason, keep track of the things that confuse you and let us know! There‚Äôs lots of documentation work to do, and it will be best if it‚Äôs informed by people who are just starting out.</p>
]]></content:encoded>
      <comments>https://jaredforsyth.com/2017/06/03/javascript-interop-with-reason-and-bucklescript/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Getting Started with Reason and BuckleScript]]></title>
      <link>https://jaredforsyth.com/2017/06/03/getting-started-with-reason-and-bucklescript/</link>
      <guid>https://jaredforsyth.com/2017/06/03/getting-started-with-reason-and-bucklescript/</guid>
      <pubDate>Sun, 04 Jun 2017 02:25:00 GMT</pubDate>
      <description>
      <![CDATA[A short tutorial aimed at JavaScript developers]]>
      
      </description>
      <content:encoded><![CDATA[<p>A couple of people have asked me how to get up and running recently, so I thought I‚Äôd put something together. If you‚Äôre looking for a ‚Äújust clone this repo &amp; go‚Äù, <a href="https://github.com/jaredly/reason-bucklescript-example" target="_blank" rel="external">here‚Äôs a very simple boilerplate</a> I put together for this post, or you can check out the <a href="https://github.com/chenglou/reason-react-example" target="_blank" rel="external">reason-react-example</a> repository.</p>
<a id="more"></a>
<h3 id="What‚Äôs_Reason?">What‚Äôs <a href="http://facebook.github.io/reason/" target="_blank" rel="external">Reason</a>?</h3><p>Reason is a transpiler for OCaml. It allows you to use a syntax that‚Äôs much more familiar to javascript developers (and anyone coming from a C-like syntax), and also supports JSX.</p>
<h3 id="What‚Äôs_OCaml?">What‚Äôs <a href="https://ocaml.org/" target="_blank" rel="external">OCaml</a>?</h3><p>OCaml is one of those languages that gets listed on ‚Äú5 programming languages that will change the way you think about programming.‚Äù</p>
<p>It‚Äôs been around for a long time (~20 years), but the community has stayed small and fairly focused on academia. Because of this, community resources are sparse, documentation is worse than other modern languages, and it‚Äôs historically taken a ton of effort to even install and manage packages.</p>
<p>The Reason initiative is very focused on making it easier for newcomers to learn OCaml and join the community.</p>
<h3 id="What‚Äôs_BuckleScript?">What‚Äôs <a href="https://github.com/bucklescript/bucklescript" target="_blank" rel="external">BuckleScript</a>?</h3><p>BuckleScript (by <a href="https://github.com/bobzhang" target="_blank" rel="external">Bob Zhang</a> over at Bloomberg) is a new backend for the ocaml compiler, which takes OCaml (or Reason) code and produces performant, readable JavaScript. It has <a href="http://bucklescript.github.io/bucklescript/Manual.html" target="_blank" rel="external">excellent documentation</a>, very readable output, and easy-to-use interop with JavaScript.</p>
<h2 id="Installation">Installation</h2><p>You can just <code>git clone</code> <a href="https://github.com/jaredly/reason-bucklescript-example" target="_blank" rel="external">https://github.com/jaredly/reason-bucklescript-example</a> to get ahead of the game if you want.</p>
<blockquote>
<p>I‚Äôm assuming you‚Äôre on a unix-like machine (linux or mac), but BuckleScript also works on windows!</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-new-project</span><br><span class="line"><span class="built_in">cd</span> my-new-project</span><br><span class="line"><span class="built_in">echo</span> &#123;&#125; &gt; package.json <span class="comment"># shortcut to avoid answering any 'npm init' questions</span></span><br><span class="line">npm install bs-platform</span><br></pre></td></tr></table></figure>
<p>Installing <code>bs-plaform</code> will take a little time (~30 seconds on my macbook pro), because it‚Äôs building the BuckleScript compiler for you.</p>
<blockquote>
<p>The version of bs-platform that I installed was <code>1.7.4</code>, so if yours is later, some details might be different. Buckelscript includes reason, so it‚Äôs the only thing you have to install!</p>
</blockquote>
<p>Then make a <code>bsconfig.json</code> file that looks like this</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"my-new-project"</span></span>,</span><br><span class="line">  "<span class="attribute">sources</span>": <span class="value"><span class="string">"src"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Your_first_file">Your first file</h2><p>In <code>src/hello.re</code>, put:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Js</span>.log <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>Now to compile, run <code>./node_modules/.bin/bsb -make-world</code>.<br>And now run the compiled javascript with <code>node ./lib/js/src/hello.js</code>!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node ./lib/js/src/hello.js</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>If you take a peek at the compiled javascript, this is what you get:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span></span><br><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
<p>Pretty nice!</p>
<h2 id="Bundling_for_the_web">Bundling for the web</h2><blockquote>
<p>If you‚Äôre targeting node, then you can skip this part. BuckleScript‚Äôs javascript output has all the <code>require</code>s you need for node to be happy.</p>
</blockquote>
<p>Once you have more than one file, you‚Äôll need a bundler like webpack or rollup. Here‚Äôs my simple <code>webpack.config.js</code> (go ahead and <code>npm install webpack</code> to install it as well).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./lib/js/src/hello.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname +<span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>And here‚Äôs a basic html file to put in <code>./public/index.html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>Hello Reason<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"./bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Now run <code>./node_modules/.bin/webpack</code> and <code>open ./public/index.html</code> and you‚Äôre good to go!</p>
<h2 id="What‚Äôs_next?">What‚Äôs next?</h2><p>If you need a primer on the syntax, the <a href="http://facebook.github.io/reason/" target="_blank" rel="external">Reason documentation</a> has a useful list of javascript comparisons.</p>
<p>I‚Äôm also writing a post about BuckleScript interop that should be helpful üòÑ.</p>
<p>If you‚Äôre interested in using React, you can take a look at the <code>react-reason-example</code> repository.</p>
<p>If you have questions or just want to hang out, <a href="https://discord.gg/reasonml" target="_blank" rel="external">join us on Discord!</a></p>
]]></content:encoded>
      <comments>https://jaredforsyth.com/2017/06/03/getting-started-with-reason-and-bucklescript/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Detecting unused styles in JavaScript with `babel-traverse`]]></title>
      <link>https://jaredforsyth.com/2017/04/08/analyzing-javascript-with-babel-traverse/</link>
      <guid>https://jaredforsyth.com/2017/04/08/analyzing-javascript-with-babel-traverse/</guid>
      <pubDate>Sat, 08 Apr 2017 21:47:36 GMT</pubDate>
      <description>
      <![CDATA[It's unexpectedly easy to do powerful analysis using the tools babel provides.]]>
      
      </description>
      <content:encoded><![CDATA[<p>Last week, my coworker <a href="https://twitter.com/crm416" target="_blank" rel="external">Charlie</a> asked what it would take to automatically detect and purge unused <a href="https://github.com/Khan/aphrodite" target="_blank" rel="external">aphrodite</a> styles in our codebase.</p>
<p>If asked 2 years ago, I probably would have gone with a regex and a string-munging python script, but I‚Äôd just spent the past few nights messing with babel plugins, and figured I could probably get pretty far with relatively little work. As it happened, I was <strong>impressed by how easy it was</strong> using the tools that babel provides.</p>
<p>As a bonus, it also works with <a href="https://github.com/facebook/react-native" target="_blank" rel="external">React Native</a> because they have the same API, and it could probably be extended to other libraries without too much work.</p>
<a id="more"></a>
<h2 id="Here‚Äôs_what_we‚Äôre_building">Here‚Äôs what we‚Äôre building</h2><p>We‚Äôre making the guts of the <a href="https://github.com/jaredly/stylecleanup" target="_blank" rel="external">stylecleanup</a> tool, which finds &amp; deletes unused styles in your JavaScript, and works with both <a href="https://github.com/Khan/aphrodite" target="_blank" rel="external">aphrodite</a> and <a href="https://github.com/facebook/react-native" target="_blank" rel="external">React Native</a>.</p>
<p><a href="https://github.com/jaredly/stylecleanup" target="_blank" rel="external"><img src="https://github.com/jaredly/stylecleanup/blob/master/docs/screencap.gif?raw=true" alt="screencap of stylecleanup in action"></a></p>
<p>For example, here‚Äôs a React Native file</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;StyleSheet, View&#125; <span class="keyword">from</span> <span class="string">'react-native'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">export default class MyComponent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">  	return &lt;View style=&#123;styles.header&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  header: &#123; backgroundColor: <span class="string">'red'</span> &#125;,</span><br><span class="line">  awesome: &#123; fontSize: 20 &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>The style <code>awesome</code> is unused, and we‚Äôd like to automatically detect that.</p>
<h2 id="Here‚Äôs_how_we_do_it">Here‚Äôs how we do it</h2><p>The rough steps are</p>
<ul>
<li>parse the JavaScript file</li>
<li>find all the stylesheet declarations, e.g. <code>const myStyleSheet = StyleSheet.create({ .... })</code></li>
<li>get a list of the styles within that stylesheet (e.g. <code>&quot;header&quot;</code>, <code>&quot;awesome&quot;</code>)</li>
<li>go through and find references to that stylesheet, e.g. <code>myStyleSheet.someStyle</code></li>
<li>from that, determine which styles are never referenced and can be safely deleted</li>
</ul>
<h3 id="Parse_the_JavaScript_file">Parse the JavaScript file</h3><p>We‚Äôll be using the libraries <a href="">babylon</a> and <a href="">babel-traverse</a>. The <a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md" target="_blank" rel="external">plugins section</a> of <a href="https://twitter.com/thejameskyle" target="_blank" rel="external">@thejameskyle</a>‚Äòs <a href="https://github.com/thejameskyle/babel-handbook" target="_blank" rel="external">babel-handbook</a> is also an excellent reference.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>)</span><br><span class="line"><span class="keyword">const</span> text = fs.readFileSync(file, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(text, &#123;</span><br><span class="line">  <span class="comment">// this means that `import` and `export` are allowed</span></span><br><span class="line">  sourceType: <span class="string">'module'</span>,</span><br><span class="line">  <span class="comment">// we want to allow all the fancy syntax</span></span><br><span class="line">  plugins: [<span class="string">'jsx'</span>, <span class="string">'flow'</span>, <span class="string">'objectRestSpread'</span>, <span class="string">'classProperties'</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Find_the_StyleSheet_declarations">Find the StyleSheet declarations</h3><p>We‚Äôll look for the form <code>const myStyleSheet = StyleSheet.create({ .... })</code></p>
<p>We‚Äôre going to use <a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="external"><code>babel-traverse</code></a>, which makes walking through the tree super easy.</p>
<p>It gives us a function, <code>traverse</code>, that will walk through the whole AST, and call the visitors we specify corresponding to the type of a given node. To figure out what the types are (and what the shape of the AST is like), I lean on <a href="https://astexplorer.net/" target="_blank" rel="external">astexplorer.net</a> and <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md" target="_blank" rel="external">the Readme</a> of <a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleSheets = []</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  CallExpression(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isStyleSheetCreate(path)) &#123;</span><br><span class="line">      <span class="keyword">const</span> members = path.node.arguments[<span class="number">0</span>].properties.filter(</span><br><span class="line">        <span class="comment">// Not gonna try to figure out spreads</span></span><br><span class="line">        property =&gt; property.type === <span class="string">'ObjectProperty'</span></span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">const</span> styleNames = members.map(member =&gt; member.key.name)</span><br><span class="line">      styleSheets.push(&#123;id: path.parent.id, styleNames&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>So I go through every <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md#callexpression" target="_blank" rel="external"><code>CallExpression</code></a>, which has the form <code>something(arg1, arg2, ...)</code>, check if it looks like <code>StyleSheet.create</code>, and then process it. The function <code>isStyleSheetCreate</code> (that I‚Äôll describe in a second) determines whether the current node looks like <code>var myStyleSheet = StyleSheet.create({y: ... })</code>. I then grab all the members of the object that‚Äôs being passed to <code>StyleSheet.create</code>, discarding any that happen to be <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md#objectmethod" target="_blank" rel="external"><code>ObjectMethod</code></a>s or <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md#objectproperty" target="_blank" rel="external"><code>computed</code></a> properties, and get the names that they‚Äôre being identified by. In our example file, <code>styleNames</code> would end up being <code>[&quot;header&quot;, &quot;awesome&quot;]</code>.</p>
<p><code>path.parent.id</code> refers to the variable name that this stylesheet is being bound to ‚Äì <code>myStyleSheet</code> in the <code>var myStyleSheet = StyleSheet.create({y: ...})</code> example.</p>
<p>So at the end of this I have a list of the stylesheets that got created and assigned to a variable, and the style names within each stylesheet.</p>
<h4 id="Let‚Äôs_look_at_isStyleSheetCreate_now-">Let‚Äôs look at <code>isStyleSheetCreate</code> now.</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isStyleSheetCreate = (&#123;node, parent&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> node.callee.type === <span class="string">'MemberExpression'</span> &amp;&amp;</span><br><span class="line">    node.callee.object.type === <span class="string">'Identifier'</span> &amp;&amp;</span><br><span class="line">    node.callee.object.name === <span class="string">'StyleSheet'</span> &amp;&amp;</span><br><span class="line">    node.callee.property.name === <span class="string">'create'</span> &amp;&amp;</span><br><span class="line">    parent.type === <span class="string">'VariableDeclarator'</span> &amp;&amp;</span><br><span class="line">    node.arguments.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">    node.arguments[<span class="number">0</span>].type === <span class="string">'ObjectExpression'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The argument I‚Äôm passing in is a <a href="https://github.com/babel/babel/blob/master/packages/babel-traverse/src/path/index.js#L14" target="_blank" rel="external"><code>NodePath</code></a> that has many attributes, but the ones we care about are <code>node</code> and <code>parent</code>, which are both nodes in our AST (again, refer to the <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md" target="_blank" rel="external">babel-types Readme</a> for more info).</p>
<p>These checks establish that</p>
<ul>
<li>The function being called is <code>StyleSheet.create</code></li>
<li>It‚Äôs only being called with one argument, which is an object literal</li>
<li>It‚Äôs being assigned to a variable (indicated by the parent being a <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md#variabledeclarator" target="_blank" rel="external"><code>VariableDeclarator</code></a></li>
</ul>
<h3 id="Find_all_the_references_to_styles">Find all the references to styles</h3><p>as in <code>myStyleSheet.someStyle</code></p>
<p><code>babel-traverse</code> actually makes this super easy for us, because it <strong>already tracks all variable references</strong>. We can just hang on to the <a href="https://github.com/babel/babel/blob/master/packages/babel-traverse/src/scope/binding.js#L14" target="_blank" rel="external"><code>Binding</code></a> object that it uses to collect references, and then iterate through them after traversal.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleSheets = []</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  CallExpression(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isStyleSheetCreate(path)) &#123;</span><br><span class="line">      <span class="keyword">const</span> members = path.node.arguments[<span class="number">0</span>].properties.filter(</span><br><span class="line">        property =&gt; property.type === <span class="string">'ObjectProperty'</span> <span class="comment">// Not gonna try to figure out spreads</span></span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">const</span> styleNames = members.map(member =&gt; member.key.name)</span><br><span class="line">      styleSheets.push(&#123;</span><br><span class="line">        id: path.parent.id,</span><br><span class="line">        styleNames,</span><br><span class="line">        <span class="comment">// hang on to the binding object for "myStyleSheet"</span></span><br><span class="line">        binding: path.scope.getBinding(path.parent.id.name)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Now we iterate through our stylesheets, and take a look at the references.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">styleSheets.forEach((&#123;id, styleNames, binding&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> referencedNames = binding.referencePaths</span><br><span class="line">    .filter(ref =&gt; ref.parent.type === <span class="string">'MemberExpression'</span> &amp;&amp; !ref.parent.computed)</span><br><span class="line">    .map(ref =&gt; ref.parent.property.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>In the example reference <code>&lt;View style={styles.header} /&gt;</code>, the <code>referencePath</code> just points to the <code>styles</code> identifier, which is the reference to our stylesheet binding. We want to get the string <code>&quot;header&quot;</code>, so we</p>
<ul>
<li>determine that we‚Äôre looking at a <a href="https://github.com/babel/babel/blob/master/packages/babel-types/readme.md#memberexpression" target="_blank" rel="external"><code>MemberExpression</code></a> (e.g. <code>styles.something</code>)</li>
<li>make sure it‚Äôs not computed (we can‚Äôt do much with <code>styles[someVariable]</code>)</li>
<li>get the property name (e.g. <code>&quot;header&quot;</code>)</li>
</ul>
<h3 id="Then_use_the_list_of_references_to_determine_which_styles_aren‚Äôt_being_used_at_all-">Then use the list of references to determine which styles aren‚Äôt being used at all.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">styleSheets.forEach((&#123;id, styleNames, binding&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> referencedNames = binding.referencePaths</span><br><span class="line">    .filter(ref =&gt; ref.parent.type === <span class="string">'MemberExpression'</span> &amp;&amp; !ref.parent.computed)</span><br><span class="line">    .map(ref =&gt; ref.parent.property.name)</span><br><span class="line">  <span class="keyword">const</span> unused = styleNames.filter(name =&gt; referencedNames.indexOf(name) === -<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// üéâ</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Just for kicks, we can also get a list of styles that are referenced, but never defined!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">styleSheets.forEach((&#123;id, styleNames, binding&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> referencedNames = binding.referencePaths</span><br><span class="line">    .filter(ref =&gt; ref.parent.type === <span class="string">'MemberExpression'</span> &amp;&amp; !ref.parent.computed)</span><br><span class="line">    .map(ref =&gt; ref.parent.property.name)</span><br><span class="line">  <span class="keyword">const</span> unused = styleNames.filter(name =&gt; referencedNames.indexOf(name) === -<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// too easy</span></span><br><span class="line">  <span class="keyword">const</span> missing = referencedNames.filter(name =&gt; styleNames.indexOf(name) === -<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="And_we‚Äôre_done!">And we‚Äôre done!</h2><p>To see the code in context, look at <a href="https://github.com/jaredly/stylecleanup/blob/master/analyzeFile.js" target="_blank" rel="external"><code>analyzeFile.js</code></a> in the <a href="https://github.com/jaredly/stylecleanup" target="_blank" rel="external"><code>stylecleanup</code></a> project.</p>
<p>For a real tool, there‚Äôs some more bookkeeping involved in</p>
<ul>
<li>showing the lines of code where e.g. a missing style is referenced</li>
<li>being conservative about what styles are definitely unused vs styles that <em>might</em> be unused ‚Äì if the stylesheet variable is used in a way that we ignore (e.g. not in a <a href="https://github.com/babel/babel/blob/master/packages/babel-types/README.md#memberexpression" target="_blank" rel="external"><code>MemberExpression</code></a>, or with a computed lookup), then there could be references to styles that we can‚Äôt track.</li>
</ul>
]]></content:encoded>
      <comments>https://jaredforsyth.com/2017/04/08/analyzing-javascript-with-babel-traverse/#disqus_comments</comments>
    </item>
    
  </channel>
</rss>
