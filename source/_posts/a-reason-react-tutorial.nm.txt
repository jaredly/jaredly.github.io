# {"type":"header","children":15}

    A ReasonReact Tutorial

# {"type":"note","children":1}

    An in-depth introduction to Reason/OCaml and the official React.js bindings, aimed at JavaScript developers.

# {"type":"code","types":{"code":{"kernelId":null,"language":"javascript","lastRun":null}}}

    /* @embed base.css */
    /* reset */
    body, div {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        flex-shrink: 0;
    }

    body {
      font: 14px "Century Gothic", Futura, sans-serif;
    }

    #root {
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }

    .app {
      width: 280px;
      max-height: 600px;
      flex: 1;
      box-shadow: 0 2px 15px #ccc;
      margin: 10px;
      align-items: stretch;
    }

    .title {
      font-size: 20px;
      align-items: center;
      padding: 20px;
    }

    .items {
      margin: 10px 0;
      text-align: center;
      flex: 1;
      overflow: auto;
    }

    .footer {
      align-items: flex-start;
      padding: 5px 10px;
    }

    .item {
      display: flex;
      padding: 10px 20px;
      align-items: center;
      flex-direction: row;
    }

    .checkbox {
      margin-right: 20px;
    }

    input[type="checkbox"] {
      margin-right: 10px;
    }

    input[type="text"] {
      align-self: stretch;
      padding: 3px 5px;
      margin-top: 20px;
    }

# {"type":"normal"}

    Are you a big fan of React, and want to know more about Reason/OCaml? I made this for you!

# {"type":"note"}

    This tutorial was updated on Nov 8, 2017 for the new "v3" syntax of
    Reason.

# {"type":"normal"}

    [Reason](http://facebook.github.io/reason/) is a project that adds a JavaScript-style syntax and a bunch of conventions and tooling to OCaml. The goal is to make this awesome language, with its powerful type system and robust multi-platform compiler, accessible to a broader audience. It's backed by the good folks at Facebook who invented and built React, and so naturally having best-in-class React interop has been a high priority.

# {"type":"normal"}

    This tutorial aims to give you a nice introduction to the syntax and type system of Reason, through the [ReasonReact library](https://reasonml.github.io/reason-react/). We'll be building a simple Todo list application.

# {"type":"normal"}

    // more

# {"type":"header","children":2}

    What are we building?

# {"type":"normal"}

    We'll build a fairly simple Todo-list application, and work through [component state](#11-step-1-adding-some-state), [mutable variables](#18-tracking-ids-w-a-mutable-ref-), and responding to [click](#14-reacting-to-events-and-changing-state) and [keyboard](#21-text-input) events.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_final />, "root");

# {"type":"header","children":6}

    Setup

# {"type":"note"}

    There are a couple of boilerplate-generator type things that you can take advantage of if you want. [reason-scripts](https://github.com/rrdelaney/reason-scripts), [create-react-reason-app](https://github.com/knowbody/crra), or [bsb -init](https://facebook.github.io/reason/gettingStarted.html#getting-started-project-setup) will get you started. I show the details here so that you know how it works under the hood.

# {"type":"normal"}

    Clone [this starter repo](https://github.com/jaredly/a-reason-react-tutorial) that has all of the config files ready for you. Here's what it contains out of the box:

# {"type":"code","types":{"code":{"kernelId":null,"language":"bash","lastRun":null}}}

    ~$ tree
    .
    â”œâ”€â”€ bsconfig.json
    â”œâ”€â”€ package.json
    â”œâ”€â”€ webpack.config.js
    â”œâ”€â”€ public
    â”‚Â Â  â”œâ”€â”€ index.html
    â”‚Â Â  â””â”€â”€ styles.css
    â””â”€â”€ src
     Â Â  â”œâ”€â”€ Main.re
     Â Â  â””â”€â”€ TodoList.re

# {"type":"header","children":3}

    bsconfig.json

# {"type":"normal"}

    This tells `bucklescript` how to compile your code. In it, we specify libraries we depend on (reason-react), that we want to use the new react-jsx transform, and that our files are in `src`.

# {"type":"code","types":{"code":{"kernelId":null,"language":"json","lastRun":null}}}

    {
      "name" : "tic-tac-toe",
      "reason" : {"react-jsx" : 2},
      "refmt": 3,
      "bs-dependencies": ["reason-react"],
      "sources": "src"
    }

# {"type":"note"}

    Here's some documentation on the [schema of bsconfig.json](http://bucklescript.github.io/bucklescript/docson/#build-schema.json). Note that source directories are **not** walked recursively. Subfolders have to be listed out.

# {"type":"header","children":4}

    package.json

# {"type":"normal"}

    For our development dependencies we have `bs-platform` (which contains the bucklescript compiler) and `webpack` (for bundling the compiled js files together).

# {"type":"normal"}

    Our runtime dependencies include both `reason-react` *and* the npm libraries that `reason-react` code depends on, `react`, and `react-dom`.

# {"type":"code","types":{"code":{"kernelId":null,"language":"json","lastRun":null}}}

    {
      "name": "reason-to-do",
      "scripts": {
        "start": "bsb -make-world -w",
        "build": "webpack -w",
        "clean": "bsb -clean-world"
      },
      "dependencies": {
        "react": "^15.4.2",
        "react-dom": "^15.4.2",
        "reason-react": "0.2.4"
      },
      "devDependencies": {
        "bs-platform": "^2.0.0",
        "webpack": "^3.0.0"
      }
    }

# {"type":"normal"}

    `npm start` will start the bucklescript compiler in watch mode, and `npm run build` will start our webpack bundler in watch mode. While developing, we'll have both these processes running.

# {"type":"header","children":2}

    webpack.config.js

# {"type":"normal"}

    Webpack also needs [some configuration](https://webpack.js.org/concepts/), so it knows what to compile and where to put it. Notice that bucklescript puts our compiled javascript into `./lib/js/`, with parallel file structure to our `./src` directory.

# {"type":"code","types":{"code":{"kernelId":null,"language":"javascript","lastRun":null}}}

    module.exports = {
      entry: './lib/js/src/main.js',
      output: {
        path: __dirname + '/public',
        filename: 'bundle.js',
      },
    };

# {"type":"header","children":3}

    Building

# {"type":"normal"}

    Open two terminals, and `npm install && npm start` in one, `npm run build` in the other. The one with `npm start` is bucklescript, which you'll want to keep an eye on -- that's the one that's going to show you error messages if you e.g. have a type error in your code. The webpack one you can pretty much ignore.

# {"type":"normal"}

    Now open `public/index.html` in your favorite browser, and you should see this!

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp />, "root");

# {"type":"header","children":7}

    Step 0: The included code

# {"type":"normal"}

    We've got two reason source files at the moment: `Main.re` and `TodoApp.re`.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* Main.re */
    ReactDOMRe.renderToElementWithId(<TodoApp />, "root");

# {"type":"normal"}

    Here we have a single function call, which translates (roughly) to `ReactDOM.render(<TodoApp />, document.getElementById("root"))`.

# {"type":"header","children":2}

    Inter-file dependencies

# {"type":"normal"}

    One thing you'll notice is that there's no `require()` or `import` statement indicating where `TodoApp` came from. In OCaml, inter-file (and indeed inter-package) dependencies are all *inferred* from your code. Basically, the compiler sees `TodoApp` isn't defined anywhere in this file, so there must be a file `TodoApp.re` (or `.ml`) somewhere that this depends on.

# {"type":"note"}

    Currently, there is no distinction made between files in your own project and files in libraries you depend on -- meaning that if `ReasonReact` had a file called `Utils.re` inside of it, you wouldn't be able to have a file named `Utils.re` in your project. As you might imagine, this is something of a mess, and is being [actively worked on](https://github.com/BuckleScript/bucklescript/issues/1584).

# {"type":"header","children":6}

    ReasonReact's JSX

# {"type":"normal"}

    Let's look at what `<TodoApp />` desugars to in ReasonReact:

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    TodoApp.make([||]);

# {"type":"normal"}

    This means "call the `make` function in the `TodoApp` module with a single argument, an empty array".

# {"type":"normal"}

    If there had been some props and some children, it would desugar like this:

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    <TodoApp some="thing" other=12> child1 child2 </TodoApp>;
    /* becomes (approximately) */
    TodoApp.make(~some="thing", ~other=12, [|child1, child2|]);

# {"type":"list","children":4}

    Some key points here

# {"type":"normal"}

    ~~Calling a function in Reason, like OCaml and Haskell, doesn't involve parenthesis or commas. `a b c` is akin to JavaScript's `a(b, c)`.~~ Starting with [Reason version 3](https://reasonml.github.io/community/blog/#reason-3), calling a function uses parentheses & commas just like JavaScript.

# {"type":"normal"}

    `[| val, val |]` is array literal syntax. An array is fixed-length & mutable, with O(1) random access, in comparison to a List, which is singly linked & immutable, with O(n) random access.

# {"type":"normal"}

    prop values don't have the `{}` curly wrappers what we know from JSX, they are parsed as expressions. So `a=some_vbl_name` is perfectly fine.

# {"type":"normal"}

    Children are also expressions -- in contrast to JSX, where they are strings by default.

# {"type":"normal"}

    So we know that `TodoApp` needs to have a `make` function that takes an array of children. Let's take a look at it.

# {"type":"header","children":7}

    Defining a component

# {"type":"note"}

    ðŸ‘‰ Mouse over any identifier or expression to see the type that OCaml has inferred for it. The `/* ... */` lines are collapsed - click to expand/collapse them.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* TodoApp.re :15 */
    let component = ReasonReact.statelessComponent("TodoApp");

    let make = (children) => {
      ...component,
      render: (self) =>
        <div className="app">
          <div className="title">
            (ReasonReact.stringToElement("What to do"))
          </div>
          <div className="items">
            (ReasonReact.stringToElement("Nothing"))
          </div>
        </div>
    };

    let hidden = "cool";
    /* in future snippets there will be real code hidden */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp />, "root");

# {"type":"normal"}

    In the `make` function, we're taking a `children` argument (but ignoring it), and returning a component definition. `ReasonReact.statelessComponent` returns a default component definition (as a [record](https://reasonml.github.io/guide/language/record)), with various lifecycle methods & other properties that you can override with the `...record spread` syntax, which is similar to es6 object spread. In this case, we only want to override the `render` function.

# {"type":"note"}

    In Reason, like OCaml, Haskell, and Lisps in general, there is no explicit `return` statement for designating the result of a function. The value of any block is equal to the value of the last expression in it. In fact, a block is nothing more than a sequence of expressions where we ignore all but the last value.

# {"type":"normal"}

    Our render function takes a single argument, `self` (here's [the type definition](https://github.com/reasonml/reason-react/blob/7a42ec9e5a1bde04ed9b630ba12ad34d82b963d1/src/reasonReact.rei#L84)). For reducer components, you can access the state via `self.state` and update it via `self.reduce`. As we're currently stateless, we don't use it at all.

# {"type":"normal"}

    We return some virtual dom elements! Tags that start with lower-case letters (like `div`) are intepreted as DOM elements, and become straight `React.createElement` calls in the compiled JS.

# {"type":"normal"}

    `ReasonReact.stringToElement` is required to satisfy the type system -- we can't drop in React elements and strings into the same array, we have to wrap the strings with this function first. In my code I often have an alias at the top of the file `let str = ReasonReact.stringToElement;` to make it less cumbersome.

# {"type":"header","children":3}

    Step 1: Adding some state

# {"type":"header","children":6}

    Declaring types

# {"type":"normal"}

    Our state will be just a list of Todo items.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* TodoApp_1_1.re :12 */
    type item = {
      title: string,
      completed: bool
    };

    type state = {
      /* this is a type w/ a type argument,
      * similar to List<Item> in TypeScript,
      * Flow, or Java */
      items: list(item)
    };

    let component = ReasonReact.reducerComponent("TodoApp");

    /* I've gone ahead and made a shortened name for converting strings to elements */
    let str = ReasonReact.stringToElement;

    let make = (children) => {
      ...component,
      initialState: () => {
        items: [
          {title: "Write some things to do", completed: false}
        ]
      },
      reducer: ((), _) => ReasonReact.NoUpdate,
      render: ({state: {items}}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title"> (str("What to do")) </div>
          <div className="items"> (str("Nothing")) </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"normal"}

    If you're familiar with [flow](https://flow.org/) or [typescript](https://www.typescriptlang.org/) this syntax shouldn't look too foreign to you.

# {"type":"normal"}

    One important difference is that you can't nest type declarations like you can in flow or typescript. For example, this is illegal:

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    type state = {
      /* won't compile! */
      items: list({
        title: string,
        completed: bool,
      })
    }

# {"type":"normal"}

    Another important thing to note is that type names (and indeed variable names) *must* start with a lower-case letter. Variant (enum) cases and Module names must start with an upper-case letter.

# {"type":"header","children":5}

    Making a reducer component

# {"type":"normal"}

    We'll start out by changing `ReasonReact.statelessComponent` to `ReasonReact.reducerComponent`. Then our `make` function gets a little more interesting.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* @show TodoApp_1_1.re 13: */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_1_1 />, "root");

# {"type":"normal"}

    `initialState` is what you'd expect, and now the first argument to our `render` function gets useful. The argument destructuring syntax is just like in JavaScript, where we get the `state.items` right out of the self argument.

# {"type":"normal"}

    The `reducer` function is currently a no-op, because we don't yet update the state at all. It will get more interesting later.

# {"type":"note"}

    I'll leave it as an exercise for the reader to fix it so that it says "1 item" instead of "1 items".

# {"type":"header","children":7}

    Reacting to events and changing state

# {"type":"normal"}

    Let's make a button that adds an item to the list.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* TodoApp_1_2.re 11:12 22:33 38: */
    type item = {
      title: string,
      completed: bool
    };
    type state = {
      items: list(item)
    };

    let component = ReasonReact.reducerComponent("TodoApp");
    let newItem = () => {title: "Click a button", completed: true};

    let str = ReasonReact.stringToElement;
    let make = (children) => {
      ...component,
      initialState: () => {
        items: [{
          title: "Write some things to do",
          completed: false
        }]
      },
      reducer: ((), _) => ReasonReact.NoUpdate,
      render: ({state: {items}}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <button
              onClick=((evt) => Js.log("didn't add something"))
            >
              (str("Add something"))
            </button>
          </div>
          <div className="items"> (str("Nothing")) </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_1_2 />, "root");

# {"type":"normal"}

    If this were JavaScript & React, this is where we'd call `this.setState`. In ReasonReact, there's two steps. First, we make an `action` type, which describes the ways that our state can be updated. To start there will be only one way to update it; adding a pre-defined item. We then make our `reducer` function handle that action type.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* TodoApp_1_3.re 9:10 26:28 */
    type item = {
      title: string,
      completed: bool
    };

    type state = {items: list(item)};

    type action =
      | AddItem;

    let component = ReasonReact.reducerComponent("TodoApp");

    let newItem = () => {title: "Click a button", completed: true};

    let str = ReasonReact.stringToElement;

    let make = (children) => {
      ...component,
      initialState: () => {
        items: [
          {title: "Write some things to do", completed: false}
        ]
      },
      reducer: (action, {items}) =>
        switch action {
        | AddItem => ReasonReact.Update({items: [newItem(), ...items]})
        },
      render: ({state: {items}, reduce}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <button onClick=(reduce((_evt) => AddItem))>
              (str("Add something"))
            </button>
          </div>
          <div className="items"> (str("Nothing")) </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"normal"}

    Then we can change the `onClick` handler to trigger that action. We do so
    by calling `reduce` with a function that will transform the event argument
    into an action. For this case, we can ignore the event argument, but in
    other cases we would e.g. extract an input value or mouse coordinates from
    it. `reduce` then returns the type that `onClick` expects, namely `evt =>
    void`. So the type of `reduce` is `('a => action) => ('a => void)`, with
    the side effect of kicking off a state transition.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* @show TodoApp_1_3.re 29:29 34:36 */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_1_3 />, "root");

# {"type":"normal"}

    Now when we click the button, the count at the bottom goes up!

# {"type":"header","children":3}

    Step 2: Rendering items

# {"type":"header","children":4}

    The TodoItem component

# {"type":"normal"}

    We're going to want to have a component for rendering the items, so let's make one. Since it's small, we won't have it be its own file -- we'll use a nested module.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* TodoApp_2_1.re :23 */
    type item = {
      title: string,
      completed: bool
    };

    let str = ReasonReact.stringToElement;

    module TodoItem = {
      let component = ReasonReact.statelessComponent("TodoItem");
      let make = (~item, children) => {
        ...component,
        render: (self) =>
          <div className="item">
            <input
              _type="checkbox"
              checked=(Js.Boolean.to_js_boolean(item.completed))
              /* TODO make interactive */
            />
            (str(item.title))
          </div>
      };
    };

    type state = {items: list(item)};

    type action =
      | AddItem;

    let component = ReasonReact.reducerComponent("TodoApp");

    let newItem = () => {title: "Click a button", completed: true};

    let make = (children) => {
      ...component,
      initialState: () => {
        items: [{
          title: "Write some things to do",
          completed: false
        }]
      },
      reducer: (action, {items}) =>
        switch action {
        | AddItem =>
          ReasonReact.Update({items: [newItem(), ...items]})
        },
      render: ({state: {items}, reduce}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <button onClick=(reduce((_evt) => AddItem))>
              (str("Add something"))
            </button>
          </div>
          <div className="items">
            (
              ReasonReact.arrayToElement(Array.of_list(
                  List.map((item) => <TodoItem item />, items)
              ))
            )
          </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render 350x100 */
    module TodoItem = TodoApp_2_1.TodoItem;

    ReactDOMRe.renderToElementWithId(
      <TodoItem
        item={TodoApp_2_1.title: "Hello world", completed: false}
      />,
      "root"
    );

# {"type":"normal"}

    So this is another stateless component, except this one accepts a property: `item`. The `~argname` syntax means "this function takes a labeled argument which is known as `item` both externally and internally". Swift and Objective C also allow you have labeled arguments, with an external name that is optionally different from the internal one. If you wanted them to be different, you would write e.g. `(~externalFacingName as internalFacingName) => `. `children` is an unnamed argument.

# {"type":"note"}

    In Reason, named arguments can be given in any order, but unnamed arguments cannot. So if you had a function `let myfn = (~a, ~b, c, d) => {}` where `c` was an `int` and `d` was a `string`, you could call it `myfn(~b=2, ~a=1, 3, "hi")` or `myfn(~a=3, 3, "hi", ~b=1)` but not `myfn(~a=2, ~b=3, "hi", 4)`.

# {"type":"header","children":9}

    Rendering a list

# {"type":"normal"}

    Now that we've got a `TodoItem` component, let's use it! We'll replace the section that's currently just `str("Nothing")` with this:

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* @show TodoApp_2_1.re 55:61 */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_2_1 />, "root");

# {"type":"normal"}

    In the center of all this you can see the function that takes our data and renders a react element.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    (item) => <TodoItem item />;

# {"type":"normal"}

    Another difference from JSX is that an attribute without a value is "punned", meaning that `<TodoItem item />` is the same as `<TodoItem item=item />`. In JSX, lone attributes are interpreted as `<TodoItem item={true} />`.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    ReasonReact.arrayToElement(Array.of_list(List.map(/*...*/ items)));

# {"type":"normal"}

    And now we've got the nuts and bolts of calling that function for each item and appeasing the type system. Another way to write the above is

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    List.map /*...*/ items |> Array.of_list |> ReasonReact.arrayToElement

# {"type":"normal"}

    The pipe `|>` is a left-associative binary operator that's defined as `a |> b == b(a)`. It can be quite nice when you've got some data and you just need to pipe it through a list of conversions.

# {"type":"header","children":9}

    Tracking ids w/ a mutable `ref`

# {"type":"normal"}

    If you're familiar with React, you'll know that we really ought to be using a [`key`](https://facebook.github.io/react/docs/lists-and-keys.html) to uniquely identify each rendered `TodoItem`, and in fact we'll want unique keys once we get around to modifying the items as well.

# {"type":"normal"}

    Let's add an `id` property to our `item` type, and add an `id` of `0` to our initialState item.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* TodoApp_2_2.re :6 42:48 */
    type item = {
      id: int,
      title: string,
      completed: bool
    };

    let str = ReasonReact.stringToElement;

    module TodoItem = {
      let component = ReasonReact.statelessComponent("TodoItem");
      let make = (~item, children) => {
        ...component,
        render: (_) =>
          <div className="item">
            <input
              _type="checkbox"
              checked=(Js.Boolean.to_js_boolean(item.completed))
              /* TODO make interactive */
            />
            (str(item.title))
          </div>
      };
    };

    type state = {
      items: list(item)
    };
    type action =
      | AddItem;

    let component = ReasonReact.reducerComponent("TodoApp");

    let lastId = 0;
    let newItem = () => {
      let lastId = lastId + 1;
      {id: lastId, title: "Click a button", completed: true}
    };

    let make = (children) => {
      ...component,
      initialState: () => {
        items: [{
          id: 0,
          title: "Write some things to do",
          completed: false
        }]
      },
      reducer: (action, {items}) => switch action {
        | AddItem => ReasonReact.Update({items: [newItem(), ...items]})
      },
      render: ({state: {items}, reduce}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <button onClick=(reduce((_evt) => AddItem))>
              (str("Add something"))
            </button>
          </div>
          <div className="items">
            (ReasonReact.arrayToElement(
              Array.of_list(
                List.map((item) => <TodoItem item />, items)
              )
            ))
          </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"normal"}

    But then, what do we do for the `newItem` function? We want to make sure that each item created has a unique id, and one way to do this is just have a variable that we increment by one each time we create a new item.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @show TodoApp_2_2.re 34:38 */

# {"type":"normal"}

    Of course this won't work -- we're just defining a new variable that's only scoped to the `newItem` function. At the top level, `lastId` remains `0`. In order to simulate a *mutable* `let` binding, we'll use a `ref`.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* TodoApp_2_3.re 34:38 */
    type item = {
      id: int,
      title: string,
      completed: bool
    };

    let str = ReasonReact.stringToElement;

    module TodoItem = {
      let component = ReasonReact.statelessComponent("TodoItem");
      let make = (~item, children) => {
        ...component,
        render: (_) =>
          <div className="item">
            <input
              _type="checkbox"
              checked=(Js.Boolean.to_js_boolean(item.completed))
              /* TODO make interactive */
            />
            (str(item.title))
          </div>
      };
    };

    type state = {
      items: list(item)
    };
    type action =
      | AddItem;

    let component = ReasonReact.reducerComponent("TodoApp");

    let lastId = ref(0);
    let newItem = () => {
      lastId := lastId^ + 1;
      {id: lastId^, title: "Click a button", completed: true}
    };

    let make = (children) => {
      ...component,
      initialState: () => {
        items: [{
          id: 0,
          title: "Write some things to do",
          completed: false
        }]
      },
      reducer: (action, {items}) => switch action {
        | AddItem => ReasonReact.Update({items: [newItem(), ...items]})
      },
      render: ({state: {items}, reduce}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <button onClick=(reduce((_evt) => AddItem))>
              (str("Add something"))
            </button>
          </div>
          <div className="items">
            (ReasonReact.arrayToElement(Array.of_list(
              List.map(
                (item) => <TodoItem
                  key=(string_of_int(item.id))
                  item
                />, items
              )
            )))
          </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"normal"}

    You update a `ref` with `:=`, and to access the value you dereference it with `^`. Now we can add our `key` property to the `<TodoItem>` components.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* @show TodoApp_2_3.re 63:68 */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_2_3 />, "root");

# {"type":"header","children":2}

    Step 3: Full interactivity

# {"type":"header","children":7}

    Checking off items

# {"type":"normal"}

    Now that our items are uniquely identified, we can enable toggling. We'll start by adding an `onToggle` prop to the `TodoItem` component, and calling it when the `div` gets clicked.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* TodoApp_3_1.re 10:15 */
    type item = {
      id: int,
      title: string,
      completed: bool
    };

    let str = ReasonReact.stringToElement;

    module TodoItem = {
      let component = ReasonReact.statelessComponent("TodoItem");
      let make = (~item, ~onToggle, children) => {
        ...component,
        render: (_) =>
          <div className="item" onClick=((_evt) => onToggle())>
            <input
              _type="checkbox"
              checked=(Js.Boolean.to_js_boolean(item.completed))
            />
            (str(item.title))
          </div>
      };
    };

    type state = {
      items: list(item)
    };
    type action =
      | AddItem
      | ToggleItem(int);

    let component = ReasonReact.reducerComponent("TodoApp");

    let lastId = ref(0);
    let newItem = () => {
      lastId := lastId^ + 1;
      {id: lastId^, title: "Click a button", completed: true}
    };

    let make = (children) => {
      ...component,
      initialState: () => {
        items: [{
          id: 0,
          title: "Write some things to do",
          completed: false
        }]
      },
      reducer: (action, {items}) => switch action {
        | AddItem => ReasonReact.Update({items: [newItem(), ...items]})
        | ToggleItem(id) =>
          let items = List.map(
            (item) =>
              item.id === id ?
                {...item, completed: ! item.completed} : item,
            items
          );
          ReasonReact.Update({items: items})
      },
      render: ({state: {items}, reduce}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <button onClick=(reduce((_evt) => AddItem))>
              (str("Add something"))
            </button>
          </div>
          <div className="items">
            (ReasonReact.arrayToElement(Array.of_list(
              List.map(
                (item) => <TodoItem
                  key=(string_of_int(item.id))
                  onToggle=(reduce(() => ToggleItem(item.id)))
                  item
                />, items
              )
            )))
          </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };


# {"type":"normal"}

    So `onToggle` has the type `unit => unit`. We now need to define another
    action, and the way to handle it. And then we pass the action creator to
    `onToggle`.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}, "children": 1}

    /* @show TodoApp_3_1.re 28:30 49:59 71:77 */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_3_1 />, "root");

# {"type":"normal"}

    Let's look a little closer at the way we're handling `ToggleItem`:

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @show TodoApp_3_1.re 51:59 */

# {"type":"normal"}

    We map over the list of items, and when we find the item to toggle we flip the `completed` boolean.

# {"type":"header","children":13}

    Text input

# {"type":"normal"}

    Having a button that always adds the same item isn't the most useful -- let's replace it with a text input. For this, we'll make a reducer component.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* TodoApp_final.re 31:51 */
    type item = {
      id: int,
      title: string,
      completed: bool
    };

    let str = ReasonReact.stringToElement;

    module TodoItem = {
      let component = ReasonReact.statelessComponent("TodoItem");
      let make = (~item, ~onToggle, children) => {
        ...component,
        render: (_) =>
          <div className="item" onClick=((evt) => onToggle())>
            <input
              _type="checkbox"
              checked=(Js.Boolean.to_js_boolean(item.completed))
            />
            (str(item.title))
          </div>
      };
    };

    let valueFromEvent = (evt) : string => (
      evt
      |> ReactEventRe.Form.target
      |> ReactDOMRe.domElementToObj
    )##value;

    module Input = {
      type state = string;
      let component = ReasonReact.reducerComponent("Input");
      let make = (~onSubmit, _) => {
        ...component,
        initialState: () => "",
        reducer: (newText, _text) => ReasonReact.Update(newText),
        render: ({state: text, reduce}) =>
          <input
            value=text
            _type="text"
            placeholder="Write something to do"
            onChange=(reduce((evt) => valueFromEvent(evt)))
            onKeyDown=((evt) =>
              if (ReactEventRe.Keyboard.key(evt) == "Enter") {
                onSubmit(text);
                (reduce(() => ""))()
              }
            )
          />
      };
    };

    type state = {
      items: list(item)
    };
    type action =
      | AddItem(string)
      | ToggleItem(int);

    let component = ReasonReact.reducerComponent("TodoApp");

    let lastId = ref(0);
    let newItem = (text) => {
      lastId := lastId^ + 1;
      {id: lastId^, title: text, completed: false}
    };
    let make = (children) => {
      ...component,
      initialState: () => {
        items: [{
          id: 0,
          title: "Write some things to do",
          completed: false
        }]
      },
      reducer: (action, {items}) =>
        switch action {
        | AddItem(text) => ReasonReact.Update({items: [newItem(text), ...items]})
        | ToggleItem(id) =>
          let items =
            List.map(
              (item) =>
                item.id === id ?
                  {...item, completed: ! item.completed} : item,
              items
            );
          ReasonReact.Update({items: items})
        },
      render: ({state: {items}, reduce}) => {
        let numItems = List.length(items);
        <div className="app">
          <div className="title">
            (str("What to do"))
            <Input onSubmit=(reduce((text) => AddItem(text))) />
          </div>
          <div className="items">
            (
              ReasonReact.arrayToElement(Array.of_list(List.map(
                (item) =>
                  <TodoItem
                    key=(string_of_int(item.id))
                    onToggle=(reduce(() => ToggleItem(item.id)))
                    item
                  />,
                items
              )))
            )
          </div>
          <div className="footer">
            (str(string_of_int(numItems) ++ " items"))
          </div>
        </div>
      }
    };

# {"type":"note"}

    For this component, our `state` type is just `string`, because that's all we need to keep track of. In fact, for the `TodoApp` component we could have just had the `list(item)` be the state, but it was useful to show an example of a `record`. We only have one kind of action here as well, so we don't need to declare a separate `action` type -- we just use a `string`.

# {"type":"normal"}

    Most of this we've seen before, but the `onChange` and `onKeyDown` handlers are new.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @show TodoApp_final.re 43:49 */

# {"type":"normal"}

    The input's `onChange` prop is called with a `Form` event, from which we get the text value and use that as the new state.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @show TodoApp_final.re 25:29 */

# {"type":"normal"}

    In JavaScript, we'd do `evt.target.value` to get the current text of the input, and this is the ReasonReact equivalent. ReasonReact's bindings don't yet have a well-typed way to get the `value` of an input element, so we take the `Dom.element` that we got from `ReactEventRe.Form.target`, convert it into a "catch-all javascript object", and get out the value with the "magic accessor syntax" `##value`.

# {"type":"normal"}

    **This is sacrificing some type safety**, and it would be best for ReasonReact to just provide a safe way to get the input text directly, but this is what we have for now. Notice that we've annotated the return value of `valueFromEvent` to be `string`. Without this, OCaml would make the return value `'a` (because we used the catch-all JavaScript object) meaning it could unify with anything, similar to the `any` type in Flow.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @show TodoApp_final.re 44:49 */

# {"type":"normal"}

    ReasonReact *does* provide a nice function for getting the `key` off of a keyboard event. So here we check if they pressed `Enter`, and if they did we call the `onSubmit` handler with the current text and fire off an action to clear out the input.

# {"type":"normal"}

    And now we can replace that filler "Add something" button with this text input. We'll change the `AddItem` action to take a single argument, the text of the new item, and pass that to our `newItem` function.

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}},"children":1}

    /* @show TodoApp_final.re 57:59 64:67 78:79 93:96 */

# {"type":"code","types":{"code":{"kernelId":null,"language":"reason","lastRun":null}}}

    /* @render */
    ReactDOMRe.renderToElementWithId(<TodoApp_final />, "root");

# {"type":"header","children":4}

    And that's it!

# {"type":"normal"}

    ðŸ˜“ thanks for sticking through, I hope this was helpful! There's definitely more we could do to this Todo list, but hopefully this gave you a good primer on how to navigate Reason and ReasonReact.

# {"type":"normal"}

    If there was anything confusing, let me know [on twitter](https://twitter.com/jaredforsyth) or open an issue [on github](https://github.com/jaredly/jaredly.github.io/issues). If you want to know more, come join our [reasonml channel on Discord](https://discord.gg/reasonml) or the [OCaml Discourse forum](https://discuss.ocaml.org/).

# {"type":"normal"}

    As you might be able to tell, there's lots of work to do on this language, but I think it's really promising! Contributions are quite welcome.

# {"type":"list","children":4}

    Other posts I've written about Reason:

# {"type":"normal"}

    [Getting started with Reason and BuckleScript](https://jaredforsyth.com/2017/06/03/getting-started-with-reason-and-bucklescript/)

# {"type":"normal"}

    [JavaScript interop with Reason and BuckleScript](https://jaredforsyth.com/2017/06/03/javascript-interop-with-reason-and-bucklescript/)

# {"type":"normal"}

    [Your first native Reason/OCaml project](https://jaredforsyth.com/2017/06/17/your-first-native-reason-ocaml-project/)

# {"type":"normal"}

    [When will Reason be ready for general use?](https://jaredforsyth.com/2017/06/23/when-will-reasonml-be-ready/)
